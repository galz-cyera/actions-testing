"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOptions = exports.loadOptions = void 0;
const fs_1 = require("fs");
const yargs_1 = __importDefault(require("yargs"));
const logger_1 = require("./logger");
let options;
async function loadOptions(args = process.argv) {
    var _a;
    let config = {};
    const lernaConfigPath = 'lerna.json';
    try {
        if ((0, fs_1.existsSync)(lernaConfigPath)) {
            const lernaConfigRaw = await (await fs_1.promises.readFile(lernaConfigPath)).toString();
            const lernaConfig = JSON.parse(lernaConfigRaw);
            config = (_a = lernaConfig['lerna-dockerize']) !== null && _a !== void 0 ? _a : {};
        }
    }
    catch (err) {
        (0, logger_1.getLogger)().debug(err);
    }
    options = await yargs_1.default
        .config(config)
        .wrap(process.stdout.columns)
        .option('baseDockerfileName', {
        description: 'The name of the base Dockerfile.',
        type: 'string',
        default: 'Dockerfile.base',
    })
        .option('templateDockerfileName', {
        description: 'The name of the Dockerfile template for all packages.',
        type: 'string',
    })
        .option('finalStage', {
        description: 'Should a final stage be added, which combines all packages.',
        type: 'boolean',
        default: true,
    })
        .option('finalDockerfileName', {
        description: 'Dockerfile-Name for custom final stages.',
        type: 'string',
    })
        .implies('finalDockerfileName', 'finalStage')
        .option('outDockerfileName', {
        description: 'Name for where output Dockerfile should be stored.',
        type: 'string',
        default: 'Dockerfile',
    })
        .option('dockerfileWorkingDir', {
        description: 'The root working directory for the created dockerfile',
        type: 'string',
        default: '/app/',
    })
        .option('packageManager', {
        description: 'The package manager used by the project.',
        type: 'string',
        default: 'npm',
        choices: ['npm', 'yarn'],
    })
        .option('lernaCommand', {
        description: 'The command used to call lerna inside the Dockerfile.',
        type: 'string',
        default: 'npx lerna',
    })
        .option('logLevel', {
        description: 'The level which should be logged.',
        type: 'string',
        default: 'info',
        choices: ['info', 'error', 'debug', 'warn'],
    })
        .option('logConsole', {
        description: 'Should be logged to the console',
        type: 'boolean',
        default: true,
    })
        .option('hoist', {
        description: 'Should the --hoist option of lerna be used inside the generated dockerfile',
        type: 'boolean',
        default: false,
    })
        .option('addPrepareStages', {
        description: 'Should stages be split into extra prepare stage.',
        type: 'boolean',
        default: false,
    })
        .parse(args);
    return options;
}
exports.loadOptions = loadOptions;
function getOptions() {
    if (!options) {
        throw new Error('options not loaded please call loadOptions first!');
    }
    return options;
}
exports.getOptions = getOptions;
//# sourceMappingURL=options.js.map