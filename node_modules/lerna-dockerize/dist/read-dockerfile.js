"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitInSteps = exports.readStage = exports.readDockerfile = void 0;
const fs_1 = require("fs");
const logger_1 = require("./logger");
const yargs_parser_1 = __importDefault(require("yargs-parser"));
async function readDockerfile(path) {
    const dockerfile = (await fs_1.promises.readFile(path)).toString();
    const steps = splitInSteps(dockerfile);
    const result = [];
    let currentStep = 0;
    while (true) {
        const readStageResult = readStage(steps, currentStep);
        if (!readStageResult) {
            break;
        }
        currentStep = readStageResult.endIndex + 1;
        result.push(readStageResult.stage);
    }
    if (result.length === 0) {
        (0, logger_1.getLogger)().warn(`The dockerfile '${path}' appears to be empty.`);
    }
    return result;
}
exports.readDockerfile = readDockerfile;
function readStage(steps, startIndex) {
    let i = startIndex;
    let baseImage;
    let stageName;
    let plattform;
    const isStageFromClause = /(FROM|from)(\s--platform=(\S+))? ([a-zA-Z0-9:_\-@.\/]*)( as ([a-zA-Z0-9:_-]*))?/;
    for (;; i++) {
        if (i >= steps.length) {
            return undefined;
        }
        const matching = steps[i].match(isStageFromClause);
        if (matching) {
            plattform = matching[3];
            baseImage = matching[4];
            stageName = matching[6];
            i++;
            break;
        }
    }
    const stepsBeforeInstall = [];
    const stepsAfterInstall = [];
    let installHit = undefined;
    for (; i < steps.length; i++) {
        if (steps[i].match(isStageFromClause)) {
            i--;
            break;
        }
        const matchesInstall = steps[i].match(/RUN (npm|yarn) (i|install|ci)((\s-?-?\S+((\s|=)\S+)?)*)/);
        if (matchesInstall) {
            const [_, npm, install, parameters] = matchesInstall;
            const isDependencyInstall = parameters.split(' ').filter(x => !!x && !x.startsWith('-')).length !== 0;
            if (!isDependencyInstall) {
                installHit = {
                    ci: undefined,
                    ignoreScripts: false,
                    onlyProduction: false,
                    ...parseInstallParameters(parameters),
                    ...(install === 'ci' ? { ci: true } : {}),
                };
                continue;
            }
        }
        (installHit ? stepsAfterInstall : stepsBeforeInstall).push(steps[i]);
    }
    return {
        endIndex: i,
        stage: {
            name: stageName,
            plattform: plattform,
            baseImage,
            stepsBeforeInstall,
            stepsAfterInstall,
            install: installHit,
        },
    };
}
exports.readStage = readStage;
function splitInSteps(content) {
    const result = [];
    const lines = content.split('\n');
    let currentStep = '';
    for (let i = 0; i < lines.length; i++) {
        currentStep += lines[i];
        // check if is multiline step
        if (lines[i].endsWith('\\')) {
            currentStep += '\n';
            continue;
        }
        result.push(currentStep);
        currentStep = '';
    }
    return result
        .filter(Boolean); // filter empty lines
}
exports.splitInSteps = splitInSteps;
function parseInstallParameters(params) {
    var _a;
    const parsed = (0, yargs_parser_1.default)(params);
    return {
        ci: parsed.ci,
        ignoreScripts: (_a = parsed.ignoreScripts) !== null && _a !== void 0 ? _a : false,
        onlyProduction: parsed.production || parsed.only === 'production',
    };
}
//# sourceMappingURL=read-dockerfile.js.map