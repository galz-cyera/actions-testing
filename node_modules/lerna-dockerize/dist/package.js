"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package = void 0;
const read_dockerfile_1 = require("./read-dockerfile");
const fs_1 = require("fs");
const path_1 = require("path");
const get_dependencies_transitive_1 = require("./get-dependencies-transitive");
const normalize_path_1 = require("./normalize-path");
const options_1 = require("./options");
const extendet_docker_syntax_1 = require("./extendet-docker-syntax");
const logger_1 = require("./logger");
const lerna_command_1 = require("./lerna-command");
class Package {
    constructor(name, lernaPackage, lernaPackageGraphNode) {
        this.name = name;
        this.lernaPackage = lernaPackage;
        this.lernaPackageGraphNode = lernaPackageGraphNode;
    }
    async findDockerfile() {
        if (!this.lernaPackage) {
            throw new Error(`The lerna package is missing for the dependency ${this.name}`);
        }
        const files = await fs_1.promises.readdir(this.lernaPackage.location);
        (0, logger_1.getLogger)().debug(`the package ${this.name} contains the following files: ${files.join(', ')}`);
        for (let file of files) {
            if (file.toLowerCase() === 'dockerfile') {
                return (0, path_1.join)(this.lernaPackage.location, file);
            }
        }
        return undefined;
    }
    async loadDockerfile(defaultDockerFile) {
        const dockerFileName = await this.findDockerfile();
        if (!dockerFileName && !defaultDockerFile) {
            throw new Error(`No Dockerfile for the package ${this.name} and no default docker file was found!`);
        }
        if (!dockerFileName) {
            (0, logger_1.getLogger)().info(`using default dockerfile for package ${this.name}`);
            this.dockerFile = defaultDockerFile;
        }
        else {
            (0, logger_1.getLogger)().info(`using custom dockerfile for package ${this.name}`);
            this.dockerFile = await (0, read_dockerfile_1.readDockerfile)(dockerFileName);
        }
        this.dockerFile = this.dockerFile.map((stage, i) => this.scopeDockerStage(stage, i));
        return this.dockerFile;
    }
    get relativePath() {
        return (0, normalize_path_1.normalizePath)((0, path_1.relative)(this.lernaPackage.rootPath, this.lernaPackage.location));
    }
    get dockerWorkingDir() {
        return (0, options_1.getOptions)().dockerfileWorkingDir + this.relativePath;
    }
    getPackageStageNamePrefix() {
        return this.name.replace(/@/gm, '').replace(/\//gm, '_');
    }
    getPrepareStageName() {
        if (!this.stageHasInstall(this.getBuildStage())) {
            return this.getBuildStageName();
        }
        if (!this.dockerFile) {
            return undefined;
        }
        if (!(0, options_1.getOptions)().addPrepareStages) {
            return this.getBuildStageName();
        }
        return this.dockerFile[this.dockerFile.length - 1].prepareStageName;
    }
    getBuildStageName() {
        var _a;
        return (_a = this.getBuildStage()) === null || _a === void 0 ? void 0 : _a.name;
    }
    getBuildStage() {
        if (!this.dockerFile) {
            return undefined;
        }
        return this.dockerFile[this.dockerFile.length - 1];
    }
    stageHasInstall(stage) {
        if (!(stage === null || stage === void 0 ? void 0 : stage.install)) {
            return false;
        }
        return true;
    }
    async getFinalizedBuildStages(packageMap) {
        if (!this.dockerFile) {
            return [];
        }
        const result = [];
        for (let stage of this.dockerFile) {
            let baseImage = stage.baseImage;
            const baseImageIsLocalStage = this.dockerFile.find(x => x.originalName === baseImage);
            if (baseImageIsLocalStage) {
                baseImage = baseImageIsLocalStage.name;
            }
            const addPrepareStage = (0, options_1.getOptions)().addPrepareStages && this.stageHasInstall(stage);
            if (addPrepareStage) {
                result.push((0, lerna_command_1.getDockerFileFromInstruction)(baseImage, stage.prepareStageName, stage.plattform));
            }
            else {
                result.push((0, lerna_command_1.getDockerFileFromInstruction)(baseImage, stage.name, stage.plattform));
            }
            result.push(`WORKDIR ${this.dockerWorkingDir}`);
            result.push(...(await (0, extendet_docker_syntax_1.applyExtendetDockerSyntax)(stage.stepsBeforeInstall, this)));
            if (!this.stageHasInstall(stage)) {
                continue;
            }
            result.push(`WORKDIR ${(0, options_1.getOptions)().dockerfileWorkingDir}`);
            const dependencyCopyContent = [];
            const dependencyPackages = (await (0, get_dependencies_transitive_1.getDependenciesTransitive)(this.name, packageMap, stage.install.onlyProduction))
                .map(dependencyName => {
                const pkg = packageMap.get(dependencyName);
                if (!pkg) {
                    throw new Error(`the package for the dependency '${dependencyName} of the package '${this.name}' was not found!'`);
                }
                return pkg;
            });
            for (let dependencyPackage of dependencyPackages) {
                const fromStageName = dependencyPackage.getBuildStageName();
                const packageDataFromStageName = dependencyPackage.getPrepareStageName();
                const dependencyWorkingDir = dependencyPackage.dockerWorkingDir;
                const packageJsonPath = (0, normalize_path_1.normalizePath)((0, path_1.join)(dependencyWorkingDir, 'package.json'));
                result.push(`COPY --from=${packageDataFromStageName} ${packageJsonPath} ${dependencyWorkingDir}/`);
                dependencyCopyContent.push(`COPY --from=${fromStageName} ${dependencyWorkingDir}/ ${dependencyWorkingDir}/`);
            }
            const bootstrapNpmDirectArgs = [
                ...(stage.install.onlyProduction ? ['--production'] : []),
            ];
            if (bootstrapNpmDirectArgs.length !== 0) {
                bootstrapNpmDirectArgs.unshift('--');
            }
            result.push([
                'RUN',
                (0, options_1.getOptions)().lernaCommand,
                'bootstrap',
                ...((0, options_1.getOptions)().hoist ? ['--hoist'] : []),
                `--scope=${this.name}`,
                '--includeDependencies',
                ...(stage.install.ignoreScripts ? ['--ignore-scripts'] : []),
                ...(stage.install.ci ? ['--ci'] : stage.install.ci === false ? ['--no-ci'] : []),
                ...bootstrapNpmDirectArgs,
            ].join(' '));
            if (addPrepareStage) {
                result.push((0, lerna_command_1.getDockerFileFromInstruction)(stage.prepareStageName, stage.name, stage.plattform));
            }
            result.push(...dependencyCopyContent);
            result.push(`WORKDIR ${this.dockerWorkingDir}`);
            result.push(...(await (0, extendet_docker_syntax_1.applyExtendetDockerSyntax)(stage.stepsAfterInstall, this)));
        }
        return result;
    }
    scopeDockerStage(stage, stageNumber) {
        const stageName = this.getPackageStageNamePrefix() + '-' + (stage.name || stageNumber);
        return {
            baseImage: stage.baseImage,
            name: stageName,
            plattform: stage.plattform,
            prepareStageName: (0, options_1.getOptions)().addPrepareStages ? `${stageName}_prepare` : undefined,
            originalName: stage.name,
            stepsBeforeInstall: [...stage.stepsBeforeInstall],
            stepsAfterInstall: [...stage.stepsAfterInstall],
            install: stage.install,
        };
    }
}
exports.Package = Package;
//# sourceMappingURL=package.js.map