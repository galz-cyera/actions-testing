"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyExtendetDockerSyntax = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const normalize_path_1 = require("./normalize-path");
const logger_1 = require("./logger");
const slim_package_1 = require("./slim-package");
const options_1 = require("./options");
const isCopy = /COPY\s+(--from=\S*\s+)?(--chown=\S*\s+)?(--if-exists\s+)?(--slim\s+)?(.*)\s+(.*)/s;
const isRun = /RUN( --if-exists)? (.+)/s;
async function applyExtendetDockerSyntax(steps, pkg) {
    const result = [];
    for (let step of steps) {
        const isCopyMatch = step.match(isCopy);
        const isRunMatch = step.match(isRun);
        const transformedStep = isCopyMatch ? await applyExtendetDockerSyntaxCopy(step, pkg) :
            isRunMatch ? applyExtendetDockerSyntaxRun(step, pkg) :
                step;
        if (transformedStep) {
            result.push(transformedStep);
        }
    }
    return result;
}
exports.applyExtendetDockerSyntax = applyExtendetDockerSyntax;
async function applyExtendetDockerSyntaxCopy(step, pkg) {
    var _a;
    const [_, fromStage, chown, ifExistsFlag, slimFlag, filesList, destination] = step.match(isCopy);
    if (fromStage) {
        const [_, fromStageName] = (_a = fromStage.match(/--from=(\S*)/)) !== null && _a !== void 0 ? _a : [];
        const isLocalStage = pkg.dockerFile.find(x => x.originalName === fromStageName);
        if (isLocalStage) {
            return `COPY --from=${isLocalStage.name} ${chown || ''} ${filesList} ${destination}`;
        }
        return step;
    }
    let files = filesList.split(' ')
        .map(file => (0, normalize_path_1.normalizePath)((0, path_1.join)(pkg.relativePath, file)))
        .filter(file => !ifExistsFlag || (0, fs_1.existsSync)(file));
    if (files.length === 0) {
        (0, logger_1.getLogger)().debug(`None of the files '${filesList}' was found in the package '${pkg.name}'. Ignoring COPY due set '--if-exists' flag.`);
        return;
    }
    if (slimFlag) {
        return await slimCopy(chown, files, destination);
    }
    return `COPY ${chown || ''} ${files.join(' ')} ${destination}`;
}
async function slimCopy(chown, files, destination) {
    if (files.length !== 1) {
        throw new Error(`Slimming multiple files is not supported!`);
    }
    const file = files[0];
    if (!file.endsWith('package.json')) {
        throw new Error('Slimming is only supported for package.json files!');
    }
    const source = await (0, slim_package_1.slimPackage)(file);
    if (destination.endsWith('/') || destination.endsWith('.')) {
        // destination is directory
        destination = (0, path_1.join)(destination, 'package.json');
    }
    return `COPY ${chown || ''} ${source} ${destination}`;
}
function applyExtendetDockerSyntaxRunIfExists(command, commandTokens, pkg) {
    if (command.startsWith('npm run')) {
        const npmCommand = commandTokens[2];
        if (npmCommand.startsWith('$')) {
            (0, logger_1.getLogger)().debug(`The npm run command '${commandTokens[2]}' looks like a variable.`);
            return ['RUN', (0, options_1.getOptions)().packageManager, 'run', npmCommand, '--if-present', ...commandTokens.slice(3)].join(' ');
        }
        if (!pkg.lernaPackage.scripts[npmCommand]) {
            (0, logger_1.getLogger)().debug(`The npm run command '${commandTokens[2]}' was not found in the package '${pkg.name}'. Ignoring RUN due set '--if-exists' flag.`);
            return;
        }
        else {
            return `RUN ${command}`;
        }
    }
    if (command.startsWith('./')) {
        if (!(0, fs_1.existsSync)((0, path_1.join)(pkg.relativePath, command.split(' ')[0]))) {
            (0, logger_1.getLogger)().debug(`The shell command '${command.split(' ')[0]}' was not found in the package '${pkg.name}'. Ignoring RUN due set '--if-exists' flag.`);
            return;
        }
        else {
            return `RUN ${command}`;
        }
    }
    (0, logger_1.getLogger)().warn(`The '--if-exists' flag is not supported for the command '${command}' and will be ignored!`);
    return `RUN ${command}`;
}
function applyExtendetDockerSyntaxRun(step, pkg) {
    const [_, ifExists, command] = step.match(isRun);
    const commandTokens = command.split(' ');
    if (ifExists) {
        return applyExtendetDockerSyntaxRunIfExists(command, commandTokens, pkg);
    }
    return `RUN ${command}`;
}
//# sourceMappingURL=extendet-docker-syntax.js.map