"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDockerFileFromInstruction = exports.Dockerize = void 0;
const command_1 = require("@lerna/command");
const filter_options_1 = require("@lerna/filter-options");
const fs_1 = require("fs");
const itterate_dependencies_1 = require("./itterate-dependencies");
const logger_1 = require("./logger");
const options_1 = require("./options");
const read_dockerfile_1 = require("./read-dockerfile");
class Dockerize extends command_1.Command {
    constructor() {
        super(...arguments);
        this.filteredPackages = [];
    }
    get requiresGit() {
        return false;
    }
    async initialize() {
        this.filteredPackages = await (0, filter_options_1.getFilteredPackages)(this.packageGraph, this.execOpts, this.options);
    }
    async execute() {
        try {
            const baseDockerFile = await (0, read_dockerfile_1.readDockerfile)((0, options_1.getOptions)().baseDockerfileName);
            const templateDockerFileName = (0, options_1.getOptions)().templateDockerfileName;
            let defaultDockerFile = undefined;
            if (templateDockerFileName) {
                defaultDockerFile = await (0, read_dockerfile_1.readDockerfile)(templateDockerFileName);
            }
            const baseStage = baseDockerFile[baseDockerFile.length - 1];
            baseStage.name = 'base';
            const result = [];
            for (let baseStage of baseDockerFile) {
                result.push(getDockerFileFromInstruction(baseStage.baseImage, baseStage.name, baseStage.plattform));
                result.push(...baseStage.stepsBeforeInstall);
                if (baseStage.install) {
                    result.push(`RUN ${(0, options_1.getOptions)().packageManager} install`);
                    result.push(...baseStage.stepsAfterInstall);
                }
            }
            const packages = await (0, itterate_dependencies_1.irrerateDependencies)(this.filteredPackages, this.packageGraph, this.concurrency, this.options.rejectCycles, defaultDockerFile);
            const packageMap = new Map();
            for (let pkg of packages) {
                packageMap.set(pkg.name, pkg);
            }
            for (let pkg of packages) {
                result.push(`# Package ${pkg.name}`);
                const finalPackageDockerfile = await pkg.getFinalizedBuildStages(packageMap);
                result.push(...finalPackageDockerfile);
            }
            if ((0, options_1.getOptions)().finalStage) {
                result.push(...(await this.createFinalStage(baseStage, packages)));
            }
            await fs_1.promises.writeFile((0, options_1.getOptions)().outDockerfileName, result.join('\n'));
        }
        catch (err) {
            (0, logger_1.getLogger)().error(err);
            process.exit(1);
        }
    }
    async createFinalStage(baseStage, packages) {
        const result = [];
        result.push(`# final stage`);
        const finalDockerfileName = (0, options_1.getOptions)().finalDockerfileName;
        let finalStages = [
            {
                baseImage: baseStage.name,
                install: {
                    ci: false,
                    ignoreScripts: false,
                    onlyProduction: false,
                },
                stepsAfterInstall: [],
                stepsBeforeInstall: [],
            },
        ];
        // overwrite final docker stage
        if (finalDockerfileName) {
            finalStages = await (0, read_dockerfile_1.readDockerfile)(finalDockerfileName);
        }
        for (let finalStage of finalStages) {
            result.push(getDockerFileFromInstruction(finalStage.baseImage, finalStage.name, finalStage.plattform));
            result.push(...finalStage.stepsBeforeInstall);
            if (finalStage.install) {
                for (let pkg of packages) {
                    result.push(`COPY --from=${pkg.getBuildStageName()} ${pkg.dockerWorkingDir} ${pkg.dockerWorkingDir}`);
                }
            }
            result.push(...finalStage.stepsAfterInstall);
        }
        return result;
    }
}
exports.Dockerize = Dockerize;
function getDockerFileFromInstruction(baseImage, stageName, plattform) {
    return [
        'FROM',
        ...(plattform ? [`--platform=${plattform}`] : []),
        baseImage,
        ...(stageName ? ['as', stageName] : []),
    ].join(' ');
}
exports.getDockerFileFromInstruction = getDockerFileFromInstruction;
//# sourceMappingURL=lerna-command.js.map